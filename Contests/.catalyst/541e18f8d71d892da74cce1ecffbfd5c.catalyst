{"title":{"en":"D. Vertical Paths","ru":"D. Вертикальные пути"},"contestId":"1675","problemIndex":"D","timeLimit":{"en":"2 seconds","ru":"2 секунды"},"memLimit":{"en":"256 megabytes","ru":"256 мегабайт"},"inputFormat":{"en":"standard input","ru":"стандартный ввод"},"outputFormat":{"en":"standard output","ru":"стандартный вывод"},"problemHtml":{"en":"<p>You are given a rooted tree consisting of $$$n$$$ vertices. Vertices are numbered from $$$1$$$ to $$$n$$$. Any vertex can be the root of a tree.</p><p>A <span class=\"tex-font-style-it\">tree</span> is a connected undirected graph without cycles. A <span class=\"tex-font-style-it\">rooted tree</span> is a tree with a selected vertex, which is called the <span class=\"tex-font-style-it\">root</span>.</p><p>The tree is specified by an array of parents $$$p$$$ containing $$$n$$$ numbers: $$$p_i$$$ is a parent of the vertex with the index $$$i$$$. The <span class=\"tex-font-style-it\">parent</span> of a vertex $$$u$$$ is a vertex that is the next vertex on the shortest path from $$$u$$$ to the root. For example, on the simple path from $$$5$$$ to $$$3$$$ (the root), the next vertex would be $$$1$$$, so the parent of $$$5$$$ is $$$1$$$.</p><p>The root has no parent, so for it, the value of $$$p_i$$$ is $$$i$$$ (the root is the only vertex for which $$$p_i=i$$$).</p><p>Find such a set of paths that:</p><ul> <li> each vertex belongs to exactly one path, each path can contain one or more vertices; </li><li> in each path each next vertex&nbsp;— is a son of the current vertex (that is, paths always lead down&nbsp;— from parent to son); </li><li> amount of paths is <span class=\"tex-font-style-bf\">minimal</span>. </li></ul><p>For example, if $$$n=5$$$ and $$$p=[3, 1, 3, 3, 1]$$$, then the tree can be divided into three paths: </p><ol> <li> $$$3 \\rightarrow 1 \\rightarrow 5$$$ (path of $$$3$$$ vertices), </li><li> $$$4$$$ (path of $$$1$$$ vertices). </li><li> $$$2$$$ (path of $$$1$$$ vertices). </li></ol><center> <img class=\"tex-graphics\" src=\"https://espresso.codeforces.com/698e7b2721c55613a4aa03e1cdbc043c74106981.png\" style=\"max-width: 100.0%;max-height: 100.0%;\">   <span class=\"tex-font-size-small\">Example of splitting a root tree into three paths for $$$n=5$$$, the root of the tree&nbsp;— node $$$3$$$.</span> </center>","ru":"<p>Задано корневое дерево из $$$n$$$ вершин. Вершины пронумерованы от $$$1$$$ до $$$n$$$. Корнем может быть любая из вершин.</p><p><span class=\"tex-font-style-it\">Дерево</span> — это связный неориентированный граф без циклов. <span class=\"tex-font-style-it\">Корневое дерево</span> — дерево с выделенной вершиной, которую называют <span class=\"tex-font-style-it\">корнем</span>.</p><p>Дерево задано массивом предков $$$p$$$, содержащим $$$n$$$ целых чисел: $$$p_i$$$&nbsp;— предок вершины с номером $$$i$$$. Предком вершины $$$u$$$ называется такая вершина, которая является следующей вершиной на кратчайшем пути от $$$u$$$ к корню. Например, на простом пути из $$$5$$$ в $$$3$$$ (корень), следующая вершина будет $$$1$$$, таким образом, предком вершины $$$5$$$ является вершина $$$1$$$.</p><p>У корня предка нет, для него в качестве $$$p_i$$$ используется значение $$$i$$$ (таким образом, корень&nbsp;— единственная вершина, для которой $$$p_i=i$$$). </p><p>Найдите такой набор путей, что:</p><ul> <li> каждая вершина принадлежит ровно одному пути, каждый путь может содержать одну или более вершину; </li><li> в каждом пути каждая очередная вершина&nbsp;— это сын текущей вершины (то есть пути всегда ведут вниз&nbsp;— от родителя к сыну); </li><li> количество путей <span class=\"tex-font-style-bf\">минимально</span>. </li></ul><p>Например, если $$$n=5$$$ и $$$p=[3, 1, 3, 3, 1]$$$, то дерево можно разбить на три пути: </p><ol> <li> $$$3 \\rightarrow 1 \\rightarrow 5$$$ (путь из $$$3$$$ вершин), </li><li> $$$4$$$ (путь из $$$1$$$ вершины), </li><li> $$$2$$$ (путь из $$$1$$$ вершины). </li></ol><center> <img class=\"tex-graphics\" src=\"https://espresso.codeforces.com/698e7b2721c55613a4aa03e1cdbc043c74106981.png\" style=\"max-width: 100.0%;max-height: 100.0%;\">   <span class=\"tex-font-size-small\">Пример разбиения корневого дерева на три пути для $$$n=5$$$, корень дерева&nbsp;— вершина $$$3$$$.</span> </center>"},"inSpecsHtml":{"en":"<div class=\"section-title\">Input</div><p>The first line of input data contains an integer $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — the number of test cases in the test.</p><p>Each test case consists of two lines.</p><p>The first of them contains an integer $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$). It is the number of vertices in the tree.</p><p>The second line contains $$$n$$$ integers $$$p_1, p_2, \\dots, p_n$$$ ($$$1 \\le p_i \\le n$$$). It is guaranteed that the $$$p$$$ array encodes some rooted tree.</p><p>It is guaranteed that the sum of the values $$$n$$$ over all test cases in the test does not exceed $$$2 \\cdot 10^5$$$.</p>","ru":"<div class=\"section-title\">Входные данные</div><p>В первой строке входных данных записано целое число $$$t$$$ ($$$1 \\le t \\le 10^4$$$) — количество наборов входных данных в тесте.</p><p>Каждый набор входных данных состоит из двух строк.</p><p>В первой из них записано целое число $$$n$$$ ($$$1 \\le n \\le 2 \\cdot 10^5$$$) — количество вершин в дереве.</p><p>Во второй записано $$$n$$$ целых чисел $$$p_1, p_2, \\dots, p_n$$$ ($$$1 \\le p_i \\le n$$$). Гарантируется, что массив $$$p$$$ кодирует некоторое корневое дерево.</p><p>Гарантируется, что сумма значений $$$n$$$ по всем наборам входных данных в тесте не превосходит $$$2 \\cdot 10^5$$$.</p>"},"outSpecsHtml":{"en":"<div class=\"section-title\">Output</div><p>For each test case on the first line, output an integer $$$m$$$ — the minimum amount of non-intersecting leading down paths that can cover all vertices of the tree.</p><p>Then print $$$m$$$ pairs of lines containing path descriptions. In the first of them print the length of the path, in the second — the sequence of vertices specifying that path in the order from top to bottom. You can output the paths in any order.</p><p>If there are several answers, output any of them.</p>","ru":"<div class=\"section-title\">Выходные данные</div><p>Для каждого набора входных данных на первой строке выведите целое число $$$m$$$ — минимальное количество непересекающихся путей, идущих сверху вниз, которыми можно покрыть все вершины дерева.</p><p>Затем выведите $$$m$$$ пар строк, содержащих описания путей. В первую из них выведите длину пути, во второй — последовательность вершин, задающих этот путь в порядке сверху вниз. Вы можете выводить пути в любом порядке.</p><p>Если ответов несколько, выведите любой из них.</p>"},"noteHtml":{"en":null,"ru":null},"sampleTestcases":[{"id":1651763335635,"input":"6\n5\n3 1 3 3 1\n4\n1 1 4 1\n7\n1 1 2 3 4 5 6\n1\n1\n6\n4 4 4 4 1 2\n4\n2 2 2 2","output":"3\n3\n3 1 5\n1\n2\n1\n4\n\n2\n2\n1 2\n2\n4 3\n\n1\n7\n1 2 3 4 5 6 7\n\n1\n1\n1\n\n3\n3\n4 1 5\n2\n2 6\n1\n3\n\n3\n2\n2 1\n1\n3\n1\n4\n","result":{"id":1651763335635,"stdout":"3\r\n3\r\n3 1 2 \r\n1\r\n4 \r\n1\r\n5 \r\n\r\n2\r\n2\r\n1 2 \r\n2\r\n4 3 \r\n\r\n1\r\n7\r\n1 2 3 4 5 6 7 \r\n\r\n1\r\n1\r\n1 \r\n\r\n3\r\n2\r\n4 3 \r\n2\r\n1 5 \r\n2\r\n2 6 \r\n\r\n3\r\n2\r\n2 1 \r\n1\r\n3 \r\n1\r\n4 \r\n\r\n","stderr":"","exitcode":0,"signal":null,"time":138,"timeout":false}}],"submitUrl":"https://codeforces.com/contest/1675/submit","language":"c++","isPartOfContest":true}